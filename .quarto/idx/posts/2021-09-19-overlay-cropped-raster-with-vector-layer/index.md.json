{"title":"Overlay cropped raster with vector layer","markdown":{"yaml":{"title":"Overlay cropped raster with vector layer","date":"2021-09-19","slug":"overlay-cropped-raster-with-vector-layer","categories":["Remote Sensing","Python"],"tags":[],"description":"Plot cropped raster and vector layer on the same figure using rasterio and matplotlib","lastmod":"2021-09-27T10:43:11+05:30","featured":"no"},"headingText":"Cropped raster and vector overlay","containsRefs":false,"markdown":"\n\nI recently faced a problem of having to plot \"cropped raster\" layer and a vector layer on the same axes. It is known that we first need to identify the spatial extent of each layer, having the same coordinate reference system.  \nRasterio does offer a plotting function `show` which can plot a raster layer with the correct spatial extent for you when we pass the dataset reader object. \n\nWhen we pass a reader object, the spatial extent is automatically read by `show` function.\n```python\nwith rs.open(path_to_file, \"r\") as src:  # import rasterio as rs\n    \n    f, ax = plt.subplots(figsize=(9,9))\n    _ = show(src, ax=ax)            # from rasterio.plot import show\n    _ = vector_layer.plot(ax=ax)    # `vector_layer` is a geodataframe (geopandas)\n```\n\n<figure>\n\n![](https://i.imgur.com/A33Vopw.png)\n\n<figcaption align = \"center\"><b><i>Fig.1 -Overlay raster with vector layer. Notice the spatial extent</i></b></figcaption>\n\n</figure>\n\n\nMoreover, if we pass a numpy array to the `show` function,  the spatial extent of that array has to be explicitly passed using the `transform` parameter of the `show` function since the numpy array does not know the corner location of the raster and thus the plot would begin with x,y: 0,0 as shown below. \n\n```python\nwith rs.open(path_to_file, \"r\") as src:\n\n    img = src.read(1) # img is a numpy array\n\n    f, ax = plt.subplots(figsize=(9,9))\n    _ = show(img, transform = src.transform, ax=ax)\n    _ = vector_layer.plot(ax=ax)\n```\n\nBut what if you want to plot a subset of the raster image, in the sense that you would like to slice the image arbitrarily and plot it. When you slice the image, the affine transformation is not the same anymore and thus plotting the sliced image would result in a plot having the spatial extent of the original image while the sliced image being magnified (Fig. 2).\n\n```python\nwith rs.open(path_to_file, \"r\") as src:\n\n    img = src.read(1)[1:-1,1:-1]\n\n    f, ax = plt.subplots(figsize=(9,9))\n    _ = show(img, transform = src.transform, ax=ax)\n    _ = vector_layer.plot(ax=ax)\n```\n\n<figure>\n\n![](https://i.imgur.com/ePTM6q0.png)\n\n<figcaption align = \"center\"><b><i>Fig.2 - Overlaid cropped raster and vector layer with incorrect spatial extents</i></b></figcaption>\n\n</figure>\n\n\nTo avert this problem, we need to find the new affine transformation of the cropped image. Luckily rasterio has a `window_transform`  method on the dataset reader which can compute the new transformation from the old one by passing the bounds of the layer. The `window_transform` function can either take a 2D N-D array indexer in the form of a tuple `((row_start, row_stop), (col_start, col_stop))` or provide offset as written in its [documentation](https://rasterio.readthedocs.io/en/latest/api/rasterio.windows.html)\n\n\n\nThe above method returns the new affine transformation, which can be passed to the `show` function for the numpy array through the `transform` parameter. We also change the read method instead of slicing the array by window parameter to maintain uniformity\n\n```python\n# load raster\nwith rs.open(path_to_file, \"r\") as src:\n    # window =  (((row_start), (row_stop)), ((col_start), (col_stop)))\n    img = src.read(1, window = ((1,-1), (1,-1)))\n    f, ax = plt.subplots(figsize=(9,9))\n    show(img, transform=src.window_transform(((1,-1), (1,-1))), ax=ax)\n\n    _ = vector_layer.plot(ax=ax)\n```\n\n<figure>\n\n![](https://i.imgur.com/uwVnq4z.png)\n\n<figcaption align = \"center\"><b><i>Fig.3 - Overlay of cropped raster and vector. Notice the updated spatial extent </i></b></figcaption>\n\n</figure>\n\n\nThe `show` method is helpful for plotting rasters or even RGB images for that matter. One of the differences with matplotlib's plotting is the order of axes. `show` expects it the bands to be the last axis while matplotlib, the first. It can also plot 4-band image, which is almost always the for satellite images.\nWhile there is an `extent` paramter in matplotlib's plotting function, `show` function is much tidier and straight-forward to implement cropped raster and overlay vector layer on it.\n\n\n\n\n\n","srcMarkdownNoYaml":"\n\nI recently faced a problem of having to plot \"cropped raster\" layer and a vector layer on the same axes. It is known that we first need to identify the spatial extent of each layer, having the same coordinate reference system.  \nRasterio does offer a plotting function `show` which can plot a raster layer with the correct spatial extent for you when we pass the dataset reader object. \n\nWhen we pass a reader object, the spatial extent is automatically read by `show` function.\n```python\nwith rs.open(path_to_file, \"r\") as src:  # import rasterio as rs\n    \n    f, ax = plt.subplots(figsize=(9,9))\n    _ = show(src, ax=ax)            # from rasterio.plot import show\n    _ = vector_layer.plot(ax=ax)    # `vector_layer` is a geodataframe (geopandas)\n```\n\n<figure>\n\n![](https://i.imgur.com/A33Vopw.png)\n\n<figcaption align = \"center\"><b><i>Fig.1 -Overlay raster with vector layer. Notice the spatial extent</i></b></figcaption>\n\n</figure>\n\n\nMoreover, if we pass a numpy array to the `show` function,  the spatial extent of that array has to be explicitly passed using the `transform` parameter of the `show` function since the numpy array does not know the corner location of the raster and thus the plot would begin with x,y: 0,0 as shown below. \n\n```python\nwith rs.open(path_to_file, \"r\") as src:\n\n    img = src.read(1) # img is a numpy array\n\n    f, ax = plt.subplots(figsize=(9,9))\n    _ = show(img, transform = src.transform, ax=ax)\n    _ = vector_layer.plot(ax=ax)\n```\n\nBut what if you want to plot a subset of the raster image, in the sense that you would like to slice the image arbitrarily and plot it. When you slice the image, the affine transformation is not the same anymore and thus plotting the sliced image would result in a plot having the spatial extent of the original image while the sliced image being magnified (Fig. 2).\n\n```python\nwith rs.open(path_to_file, \"r\") as src:\n\n    img = src.read(1)[1:-1,1:-1]\n\n    f, ax = plt.subplots(figsize=(9,9))\n    _ = show(img, transform = src.transform, ax=ax)\n    _ = vector_layer.plot(ax=ax)\n```\n\n<figure>\n\n![](https://i.imgur.com/ePTM6q0.png)\n\n<figcaption align = \"center\"><b><i>Fig.2 - Overlaid cropped raster and vector layer with incorrect spatial extents</i></b></figcaption>\n\n</figure>\n\n\nTo avert this problem, we need to find the new affine transformation of the cropped image. Luckily rasterio has a `window_transform`  method on the dataset reader which can compute the new transformation from the old one by passing the bounds of the layer. The `window_transform` function can either take a 2D N-D array indexer in the form of a tuple `((row_start, row_stop), (col_start, col_stop))` or provide offset as written in its [documentation](https://rasterio.readthedocs.io/en/latest/api/rasterio.windows.html)\n\n\n## Cropped raster and vector overlay\n\nThe above method returns the new affine transformation, which can be passed to the `show` function for the numpy array through the `transform` parameter. We also change the read method instead of slicing the array by window parameter to maintain uniformity\n\n```python\n# load raster\nwith rs.open(path_to_file, \"r\") as src:\n    # window =  (((row_start), (row_stop)), ((col_start), (col_stop)))\n    img = src.read(1, window = ((1,-1), (1,-1)))\n    f, ax = plt.subplots(figsize=(9,9))\n    show(img, transform=src.window_transform(((1,-1), (1,-1))), ax=ax)\n\n    _ = vector_layer.plot(ax=ax)\n```\n\n<figure>\n\n![](https://i.imgur.com/uwVnq4z.png)\n\n<figcaption align = \"center\"><b><i>Fig.3 - Overlay of cropped raster and vector. Notice the updated spatial extent </i></b></figcaption>\n\n</figure>\n\n\nThe `show` method is helpful for plotting rasters or even RGB images for that matter. One of the differences with matplotlib's plotting is the order of axes. `show` expects it the bands to be the last axis while matplotlib, the first. It can also plot 4-band image, which is almost always the for satellite images.\nWhile there is an `extent` paramter in matplotlib's plotting function, `show` function is much tidier and straight-forward to implement cropped raster and overlay vector layer on it.\n\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en-GB","fig-responsive":true,"quarto-version":"1.3.450","theme":["sandstone","../../_variables.scss"],"page-layout":"article","fontsize":"1.1em","linestretch":1.7,"fontcolor":"black","author":[{"id":"cvc","number":1,"name":{"given":"Aman","family":"Bagrecha","literal":"Aman Bagrecha","non-dropping-particle":"von"},"orcid":"0000-0003-3131-0864","email":"jainaman588@gmail.com"}],"mermaid":{"theme":"neutral"},"title":"Overlay cropped raster with vector layer","date":"2021-09-19","slug":"overlay-cropped-raster-with-vector-layer","categories":["Remote Sensing","Python"],"tags":[],"description":"Plot cropped raster and vector layer on the same figure using rasterio and matplotlib","lastmod":"2021-09-27T10:43:11+05:30","featured":"no"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}