{"title":"Vector tiles and Docker using pg_tilerserv","markdown":{"yaml":{"title":"Vector tiles and Docker using pg_tilerserv","date":"2021-12-22","slug":"vector-tiles-and-docker-using-pg-tilerserv","categories":["Docker","Vector-tiles"],"tags":["Docker","Vector-tiles"],"subtitle":"","description":"Serve your geospatial data as Vector Tiles using pg_tileserv in a Docker container","authors":[],"lastmod":"2021-12-22T00:19:15+05:30","featured":"no","image":"featured.png","projects":[]},"headingText":"What are vector tiles?","containsRefs":false,"markdown":"\n\n\nIn this blog we look at how to serve your geospatial data as vector tiles using pg_tileserv in a docker container. \n\nVector Tiles are similar to raster tiles, but instead of serving images, vector tiles serve geospatial data which are vectors themselves and not images. This allows for reduced data transfer over a network, faster loading while allowing client side rendering. Moreover, vector tiles allow for flexible styling of your geospatial data since it renders on the client side. All this is not possible with raster tiles and hence vector tiles have gained traction in the last few years.\n\nOne of the most popular specifications to serve vector tiles is mapbox vector tiles, utilized by many open source tile servers.\n\nBecause PostGIS can create mapbox vector tiles from vector data, it becomes easy to serve them over the web. Many tileservers use the power of this postGIS functionality to serve vector tiles over the web. \n\nAs for a visual understanding as to what is different between vector and raster tiles, the following image illustrates that. The red bounding box is the response to clients request to serve vector tiles. Notice the format is `pbf` as opposed to `png` for raster tiles.\n\n![](https://i.imgur.com/S5uzLpN.png)\n\n\n## Why use docker for this?\nUsing docker would expedite the process of starting and \"actually\" using the applications. It is like sharing your machine with others so that they do not have to install anything to get started. For this reason, it makes complete sense to use docker for moderate to high complexity projects.\n\n## What is pg_tileserve?\nTo create vector tiles, and serve them on the web, you need a middleware that can talk to the database and also serve them on the web. Since pg_tileserve uses a postgis function under the hood, it becomes a default choice to add a lightweight service to serve vector tiles. pg_tileserv returns Mapbox Vector tiles on input of vector geometry. In addition to reading tables from the database, it can handle complex functions to meet our needs.\n\nST_asMVT, an aggregate function which is used under the hood for pg_tileserv, returns mapbox vector tile format based on google protobuf. While there are other formats such as MBtiles which is sqlite based binary file (can be opened in sqlite), Mapbox Vector Tile format seems to be winning this race and is thus the most popular format currently.\n\n\n### To get started with serving your vector data to the web using pg_tileserv, we follow the below mentioned steps\n\n1. Download [pg_tileserv](https://github.com/CrunchyData/pg_tileserv) folder from [down-git](https://downgit.github.io/#/home) website and save it to your local directory. \n![](https://i.imgur.com/QkF6OF9.png)\n\nThe folder contains all the files required to start a docker container and serve vector tiles.\n```\n└───data/  — would contain all your vector data\n└───load-data.sh — shell script to load data into PostgreSQL\n└───pg_tileserv.env — database URL to connect\n└───docker-compose.yml — \n└───pg.env — environment variable for database\n└───cleanup.sh — assemble multiple containers\n└───README — guide to setup docker by Just van den Broecke\n```\n\n2. Next, Modify `docker-compose.yml` file under **build->context** to point to the docker file https://github.com/CrunchyData/pg_tileserv.git. Since we did not clone the repository, we specify the Dockerfile using the git link. \n\n![](https://i.imgur.com/AzclY3c.png)\n\n3. Dump all your geospatial data into `data` dir. This directory will be *mounted* to the container, once we start it.\n\n5. Change the `pg_tileserv.env` environment file as you wish, to specify the name and password of your database.\n\nNotes on env files: \n- `pg_tilerserv.env` file contains the database url which is of the format `postgres://your-username:your-password@localhost:5432/your-database-name` while `pg.env` contains credentials for postgres database.\n\nNotes on docker-compose file\n- We are mounting `data` dir from our local system to the work dir in the docker container.\n- We are mapping port 7800 from our local machine to 7800 to the pg_tileserv container.\n\n\nStart Docker Desktop and run `docker-compose build` in the command line. It will download the image needed from the dockerfile specified. It only downloads the latest alpine image and all other dependencies are installed in the build.\n\nOnce the database setup is done, we now load data into the database by running either `load-data.sh` shell script (or) the following command,\n\n```sh\n#Load data using shp2pgsql \ndocker-compose exec pg_tileserv_db sh -c \"shp2pgsql -D -s 4326 /work/ne_50m_admin_0_countries.shp | psql -U tileserv -d tileserv\"\n```\nThe above command opens a terminal inside the pg_tileserv_db container and runs the `shp2pgsql` command.\n\nWe can use `ogr2ogr` command line tool if your data is anything other than shapefile. Read this blog by [Kat Batuigas](https://blog.crunchydata.com/blog/loading-data-into-postgis-an-overview) to know how to do it.\n\n\nFinally, run `docker-compose up` to start the service. You'd see both containers starting up and your web app being served on port 7800. If you do not see this, stop the container and run again.\n\n![](https://i.imgur.com/Gy4QlTL.png)\n\nOn running the web app in the browser we see our tables visible under Table Layers and the schema it belongs to. We added a few additional layers (public.hydrants and a function layer following steps from `README.md`) to play around with it.\n\n\n![](https://i.imgur.com/CwmhUdK.png)\n\n\n## Endnote\n\nWe looked at serving vector data as tiles using pg_tileserv and docker container. Docker enables reproducibility and expedites the process of running a web app. Although there are numerous open-source tile servers available, each has its use case and would require testing them out to identify the best tileserver for your use case. You can read a long list of tileservers [here](https://github.com/mapbox/awesome-vector-tiles).\n\nSo next time you think to serve large vector data on the web app, make sure to use vector tiles built inside a docker container. It will surely simplify things!\n\nSource: \n1. CrunchyData/pg_tileserv: A very thin PostGIS-only tile server in Go. Takes in HTTP tile requests, executes SQL, returns MVT tiles. (https://github.com/CrunchyData/pg_tileserv/)\n\n2. Lightweight PostGIS Web Services Using pg tileserv and pg featureserv (https://www.youtube.com/watch?v=TXPtocZWr78&t=1s&ab_channel=CrunchyData)\n\n3. Reference | Vector tiles | Mapbox (https://docs.mapbox.com/vector-tiles/reference/)\n\n4. Vector Tiles – Geoinformation HSR (https://giswiki.hsr.ch/Vector_Tiles)\n","srcMarkdownNoYaml":"\n\n\nIn this blog we look at how to serve your geospatial data as vector tiles using pg_tileserv in a docker container. \n\n## What are vector tiles?\nVector Tiles are similar to raster tiles, but instead of serving images, vector tiles serve geospatial data which are vectors themselves and not images. This allows for reduced data transfer over a network, faster loading while allowing client side rendering. Moreover, vector tiles allow for flexible styling of your geospatial data since it renders on the client side. All this is not possible with raster tiles and hence vector tiles have gained traction in the last few years.\n\nOne of the most popular specifications to serve vector tiles is mapbox vector tiles, utilized by many open source tile servers.\n\nBecause PostGIS can create mapbox vector tiles from vector data, it becomes easy to serve them over the web. Many tileservers use the power of this postGIS functionality to serve vector tiles over the web. \n\nAs for a visual understanding as to what is different between vector and raster tiles, the following image illustrates that. The red bounding box is the response to clients request to serve vector tiles. Notice the format is `pbf` as opposed to `png` for raster tiles.\n\n![](https://i.imgur.com/S5uzLpN.png)\n\n\n## Why use docker for this?\nUsing docker would expedite the process of starting and \"actually\" using the applications. It is like sharing your machine with others so that they do not have to install anything to get started. For this reason, it makes complete sense to use docker for moderate to high complexity projects.\n\n## What is pg_tileserve?\nTo create vector tiles, and serve them on the web, you need a middleware that can talk to the database and also serve them on the web. Since pg_tileserve uses a postgis function under the hood, it becomes a default choice to add a lightweight service to serve vector tiles. pg_tileserv returns Mapbox Vector tiles on input of vector geometry. In addition to reading tables from the database, it can handle complex functions to meet our needs.\n\nST_asMVT, an aggregate function which is used under the hood for pg_tileserv, returns mapbox vector tile format based on google protobuf. While there are other formats such as MBtiles which is sqlite based binary file (can be opened in sqlite), Mapbox Vector Tile format seems to be winning this race and is thus the most popular format currently.\n\n\n### To get started with serving your vector data to the web using pg_tileserv, we follow the below mentioned steps\n\n1. Download [pg_tileserv](https://github.com/CrunchyData/pg_tileserv) folder from [down-git](https://downgit.github.io/#/home) website and save it to your local directory. \n![](https://i.imgur.com/QkF6OF9.png)\n\nThe folder contains all the files required to start a docker container and serve vector tiles.\n```\n└───data/  — would contain all your vector data\n└───load-data.sh — shell script to load data into PostgreSQL\n└───pg_tileserv.env — database URL to connect\n└───docker-compose.yml — \n└───pg.env — environment variable for database\n└───cleanup.sh — assemble multiple containers\n└───README — guide to setup docker by Just van den Broecke\n```\n\n2. Next, Modify `docker-compose.yml` file under **build->context** to point to the docker file https://github.com/CrunchyData/pg_tileserv.git. Since we did not clone the repository, we specify the Dockerfile using the git link. \n\n![](https://i.imgur.com/AzclY3c.png)\n\n3. Dump all your geospatial data into `data` dir. This directory will be *mounted* to the container, once we start it.\n\n5. Change the `pg_tileserv.env` environment file as you wish, to specify the name and password of your database.\n\nNotes on env files: \n- `pg_tilerserv.env` file contains the database url which is of the format `postgres://your-username:your-password@localhost:5432/your-database-name` while `pg.env` contains credentials for postgres database.\n\nNotes on docker-compose file\n- We are mounting `data` dir from our local system to the work dir in the docker container.\n- We are mapping port 7800 from our local machine to 7800 to the pg_tileserv container.\n\n\nStart Docker Desktop and run `docker-compose build` in the command line. It will download the image needed from the dockerfile specified. It only downloads the latest alpine image and all other dependencies are installed in the build.\n\nOnce the database setup is done, we now load data into the database by running either `load-data.sh` shell script (or) the following command,\n\n```sh\n#Load data using shp2pgsql \ndocker-compose exec pg_tileserv_db sh -c \"shp2pgsql -D -s 4326 /work/ne_50m_admin_0_countries.shp | psql -U tileserv -d tileserv\"\n```\nThe above command opens a terminal inside the pg_tileserv_db container and runs the `shp2pgsql` command.\n\nWe can use `ogr2ogr` command line tool if your data is anything other than shapefile. Read this blog by [Kat Batuigas](https://blog.crunchydata.com/blog/loading-data-into-postgis-an-overview) to know how to do it.\n\n\nFinally, run `docker-compose up` to start the service. You'd see both containers starting up and your web app being served on port 7800. If you do not see this, stop the container and run again.\n\n![](https://i.imgur.com/Gy4QlTL.png)\n\nOn running the web app in the browser we see our tables visible under Table Layers and the schema it belongs to. We added a few additional layers (public.hydrants and a function layer following steps from `README.md`) to play around with it.\n\n\n![](https://i.imgur.com/CwmhUdK.png)\n\n\n## Endnote\n\nWe looked at serving vector data as tiles using pg_tileserv and docker container. Docker enables reproducibility and expedites the process of running a web app. Although there are numerous open-source tile servers available, each has its use case and would require testing them out to identify the best tileserver for your use case. You can read a long list of tileservers [here](https://github.com/mapbox/awesome-vector-tiles).\n\nSo next time you think to serve large vector data on the web app, make sure to use vector tiles built inside a docker container. It will surely simplify things!\n\nSource: \n1. CrunchyData/pg_tileserv: A very thin PostGIS-only tile server in Go. Takes in HTTP tile requests, executes SQL, returns MVT tiles. (https://github.com/CrunchyData/pg_tileserv/)\n\n2. Lightweight PostGIS Web Services Using pg tileserv and pg featureserv (https://www.youtube.com/watch?v=TXPtocZWr78&t=1s&ab_channel=CrunchyData)\n\n3. Reference | Vector tiles | Mapbox (https://docs.mapbox.com/vector-tiles/reference/)\n\n4. Vector Tiles – Geoinformation HSR (https://giswiki.hsr.ch/Vector_Tiles)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en-GB","fig-responsive":true,"quarto-version":"1.3.450","theme":["sandstone","../../_variables.scss"],"page-layout":"article","fontsize":"1.1em","linestretch":1.7,"fontcolor":"black","author":[{"id":"cvc","number":1,"name":{"given":"Aman","family":"Bagrecha","literal":"Aman Bagrecha","non-dropping-particle":"von"},"orcid":"0000-0003-3131-0864","email":"jainaman588@gmail.com"}],"mermaid":{"theme":"neutral"},"title":"Vector tiles and Docker using pg_tilerserv","date":"2021-12-22","slug":"vector-tiles-and-docker-using-pg-tilerserv","categories":["Docker","Vector-tiles"],"tags":["Docker","Vector-tiles"],"subtitle":"","description":"Serve your geospatial data as Vector Tiles using pg_tileserv in a Docker container","authors":[],"lastmod":"2021-12-22T00:19:15+05:30","featured":"no","image":"featured.png","projects":[]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}