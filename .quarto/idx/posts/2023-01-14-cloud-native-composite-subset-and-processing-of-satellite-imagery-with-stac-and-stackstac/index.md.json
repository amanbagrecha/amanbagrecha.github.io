{"title":"Cloud Native Composite, Subset and Processing of Satellite Imagery with STAC and Stackstac","markdown":{"yaml":{"title":"Cloud Native Composite, Subset and Processing of Satellite Imagery with STAC and Stackstac","date":"2023-01-14","slug":"cloud-native-composite-subset-and-processing-of-satellite-imagery-with-stac-and-stackstac","categories":["Python"],"tags":["xarray","STAC"],"description":"","image":"featured.png"},"containsRefs":false,"markdown":"\n\n\n>If you wanted to collect all Sentinel satellite data for a given region of interest (ROI), say, for a given day or time frame - is there any simple way to do it? That means: Without having to download all the full images manually and cropping the ROI subset manually as well afterwards?\n\nThis, well articulated question, was the one which I was facing and made me ponder to think if we could do this using STAC and Python.\n\n---\n\nI had a road network layer over which I needed satellite imagery. The problem with my road network is that it has a large spatial extent, causing a single satellite imagery to not cover it entirely. Moreover, because of this large extent, I need two adjacent tiles to be in the same Coordinate Reference System.\n\n<figure>\n\n![](https://i.imgur.com/FHLQbBo.png)\n<figcaption align = \"center\"><b><i>Fig.1 - Road network (in red) spanning multiple UTM Zones. Basemap from OSM.</i></b></figcaption>\n\n</figure>\n\n\nWhat I needed was,\n- A way to aggregate all the adjacent tiles for a single day\n- Convert to a single CRS on the fly\n- Subset the data to my region\n- Create a composite (merge) and perform analysis on the fly\n\nIt turns out Python (and its ecosystem of great geospatial packages) along with STAC allows us to do just that.\n\nWhat is STAC?\n> STAC (SpatioTemporal Asset Catalog) is an open-source specification for describing satellite imagery and the associated metadata.\n\nWe will use `stackstac`, which is a Python package for efficiently managing and analysing large amounts of satellite imagery data in a cloud computing environment.\n\nFirst, we search through the sentinel-2 collection for our area of interest from element84 provided STAC endpoint.\n\n```\nfrom pystac_client import Client\n\nURL = 'https://earth-search.aws.element84.com/v0/'\n\nclient = Client.open(URL)\n```\n\n```\nsearch = client.search(\n    max_items = 10,\n    collections = \"sentinel-s2-l2a-cogs\",\n    intersects = aoi_as_multiline,\n    datetime = '2022-01-01/2022-01-24'\n)\n```\n\nThe resultant `search` object is passed to `stack` method on `stackstac` along with providing the destination CRS, the region of bounds and the assets required.\n\n```\nimport stackstac\n\nds = stackstac.stack(search.get_all_items() ,  epsg=4326, assets=[\"B04\", \"B03\", \"B05\"],\nbounds_latlon= aoi_as_multiline.bounds )\n\n```\nThe above line does a lot of things under the hood. It transforms the CRS of each tile from their native CRS to EPSG:4326. It also clips the tiles to our AOI. It also filters only 3 bands out of the possible 15 sentinel-2 bands. \nThe output `ds` is a `xarray.DataArray` object and it is a known fact how much is possible with very little code in xarray.\n\nAs such, we can group by a date and mosaic those tiles very easily using xarray as shown below.\n\n```\ndsf = ds.groupby(\"time.date\").median()\n```\n\n<figure>\n\n![](https://i.imgur.com/BLCu4xs.png)\n<figcaption align = \"center\"><b><i>Fig.2 - Our DataArray is 3.37GB with 4 dimensions (time, bands, x, y) respectively.</i></b></figcaption>\n\n</figure>\n\nSince xarray loads lazily, we did not perform any computation so far. But we can see how much data we are going to end up storing as shown in Figure 2.\n\nWhen I run the `compute` method on the output, it does the computation in 4 minutes (here) i.e, processing ~3.5GB in 4 mins and computing the median across the dates.\n\n```\nres = dsf.compute()\n```\n\nAt the end of this process, I have 4 images for each of the 4 dates, clipped to my region of interest in the CRS that I desire. \n\n---\nThe above method of processing large volume data is super handy and can be scaled very easily with cloud infrastructure. What is unique about this approach is that I did not have to download data, convert or know the CRS of each tile, worrying about the bounds of my region of interest.\nRead more about how stackstac works [here](https://stackstac.readthedocs.io/).\n\nThe code can be found [here](https://colab.research.google.com/drive/1NcwW7S58PkZFnrGaCyOcA5uLTxymdbZl?usp=sharing).","srcMarkdownNoYaml":"\n\n\n>If you wanted to collect all Sentinel satellite data for a given region of interest (ROI), say, for a given day or time frame - is there any simple way to do it? That means: Without having to download all the full images manually and cropping the ROI subset manually as well afterwards?\n\nThis, well articulated question, was the one which I was facing and made me ponder to think if we could do this using STAC and Python.\n\n---\n\nI had a road network layer over which I needed satellite imagery. The problem with my road network is that it has a large spatial extent, causing a single satellite imagery to not cover it entirely. Moreover, because of this large extent, I need two adjacent tiles to be in the same Coordinate Reference System.\n\n<figure>\n\n![](https://i.imgur.com/FHLQbBo.png)\n<figcaption align = \"center\"><b><i>Fig.1 - Road network (in red) spanning multiple UTM Zones. Basemap from OSM.</i></b></figcaption>\n\n</figure>\n\n\nWhat I needed was,\n- A way to aggregate all the adjacent tiles for a single day\n- Convert to a single CRS on the fly\n- Subset the data to my region\n- Create a composite (merge) and perform analysis on the fly\n\nIt turns out Python (and its ecosystem of great geospatial packages) along with STAC allows us to do just that.\n\nWhat is STAC?\n> STAC (SpatioTemporal Asset Catalog) is an open-source specification for describing satellite imagery and the associated metadata.\n\nWe will use `stackstac`, which is a Python package for efficiently managing and analysing large amounts of satellite imagery data in a cloud computing environment.\n\nFirst, we search through the sentinel-2 collection for our area of interest from element84 provided STAC endpoint.\n\n```\nfrom pystac_client import Client\n\nURL = 'https://earth-search.aws.element84.com/v0/'\n\nclient = Client.open(URL)\n```\n\n```\nsearch = client.search(\n    max_items = 10,\n    collections = \"sentinel-s2-l2a-cogs\",\n    intersects = aoi_as_multiline,\n    datetime = '2022-01-01/2022-01-24'\n)\n```\n\nThe resultant `search` object is passed to `stack` method on `stackstac` along with providing the destination CRS, the region of bounds and the assets required.\n\n```\nimport stackstac\n\nds = stackstac.stack(search.get_all_items() ,  epsg=4326, assets=[\"B04\", \"B03\", \"B05\"],\nbounds_latlon= aoi_as_multiline.bounds )\n\n```\nThe above line does a lot of things under the hood. It transforms the CRS of each tile from their native CRS to EPSG:4326. It also clips the tiles to our AOI. It also filters only 3 bands out of the possible 15 sentinel-2 bands. \nThe output `ds` is a `xarray.DataArray` object and it is a known fact how much is possible with very little code in xarray.\n\nAs such, we can group by a date and mosaic those tiles very easily using xarray as shown below.\n\n```\ndsf = ds.groupby(\"time.date\").median()\n```\n\n<figure>\n\n![](https://i.imgur.com/BLCu4xs.png)\n<figcaption align = \"center\"><b><i>Fig.2 - Our DataArray is 3.37GB with 4 dimensions (time, bands, x, y) respectively.</i></b></figcaption>\n\n</figure>\n\nSince xarray loads lazily, we did not perform any computation so far. But we can see how much data we are going to end up storing as shown in Figure 2.\n\nWhen I run the `compute` method on the output, it does the computation in 4 minutes (here) i.e, processing ~3.5GB in 4 mins and computing the median across the dates.\n\n```\nres = dsf.compute()\n```\n\nAt the end of this process, I have 4 images for each of the 4 dates, clipped to my region of interest in the CRS that I desire. \n\n---\nThe above method of processing large volume data is super handy and can be scaled very easily with cloud infrastructure. What is unique about this approach is that I did not have to download data, convert or know the CRS of each tile, worrying about the bounds of my region of interest.\nRead more about how stackstac works [here](https://stackstac.readthedocs.io/).\n\nThe code can be found [here](https://colab.research.google.com/drive/1NcwW7S58PkZFnrGaCyOcA5uLTxymdbZl?usp=sharing)."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../_variables.scss"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en-GB","fig-responsive":true,"quarto-version":"1.3.450","theme":["sandstone"],"page-layout":"article","fontsize":"1.1em","linestretch":1.7,"fontcolor":"black","author":[{"id":"cvc","number":1,"name":{"given":"Aman","family":"Bagrecha","literal":"Aman Bagrecha","non-dropping-particle":"von"},"orcid":"0000-0003-3131-0864","email":"jainaman588@gmail.com"}],"mermaid":{"theme":"neutral"},"title":"Cloud Native Composite, Subset and Processing of Satellite Imagery with STAC and Stackstac","date":"2023-01-14","slug":"cloud-native-composite-subset-and-processing-of-satellite-imagery-with-stac-and-stackstac","categories":["Python"],"tags":["xarray","STAC"],"description":"","image":"featured.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}