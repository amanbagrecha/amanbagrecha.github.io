{"title":"How to save Earth Engine Image directly to your local machine","markdown":{"yaml":{"title":"How to save Earth Engine Image directly to your local machine","date":"2022-02-07","slug":"how-to-save-earth-engine-image-directly-to-your-local-machine","categories":["earth-engine"],"tags":["earth-engine","python"],"subtitle":"","description":"In this post I show a trick which can let you download upto 100 times larger size images, directly to your local machine. Spoiler: `getRegion` method plays a significant role to help accomplish this task.","lastmod":"2022-02-07T22:19:19+05:30","featured":"no","image":"featured.png"},"headingText":"generate points","containsRefs":false,"markdown":"\n\nOftentimes you are required to download satellite images for your Area of Interest (AOI) and Google Earth Engine is probably a good place to avail processed satellite images for free and more importantly, only for the area you need.\n\nOne hindrance when you download from earth engine is that the images get saved in google drive, which can fill up fast for large numbers of downloads. To avoid this additional step, there is a hacky trick to download images directly.\n\nNote: Earth Engine does provide getDownloadURL option, but is limited in the size of download and thus not feasible in this case. Pixel grid dimensions for [getDownloadURL](https://developers.google.com/earth-engine/apidocs/ee-image-getdownloadurl) must be less than or equal to 10000 i.e, you can have a maximum of 100 x 100 pixel size images.\n\nIn this post I show a trick which can let you download upto 100 times larger size images, directly to your local machine. Spoiler: [getRegion](https://developers.google.com/earth-engine/apidocs/ee-imagecollection-getregion) method plays a significant role to help accomplish this task. Added to that, creating a gridded bounding box for our AOI, with spacing equivalent to the pixel size will aid in our task.\n\nWe will utilize earth engine python client so that all the geopython goodies can be simultaneously utilised.\n\nTo begin with, I have a geopackage containing a polygon, which is our AOI. We aim to download sentinel-2 B4 band for the region. The ideal way would be to use the in-built `Export` option, but in our case we would use the [getRegion](https://developers.google.com/earth-engine/apidocs/ee-imagecollection-getregion) method along with creating a point grid over our AOI with spacing equivalent to the pixel size.\n\n\n<figure>\n\n![](https://i.imgur.com/IA5OTuN.png)\n\n<figcaption align = \"center\"><b><i>Fig.1 -Left: Our Area of Interest over which to download satellite data. Right: Grid points over AOI bounding box at pixel spacing</i></b></figcaption>\n\n</figure>\n\nTo accomplish creation of points at spacing equal to pixel width and height, we use the following function\n\n```python\ndef xcor(y_pt, crs):\n    def wrap(x_each):\n        feat = ee.FeatureCollection(y_pt.map(lambda y_each: ee.Feature(\n            ee.Geometry.Point([x_each, y_each], ee.Projection(crs)))))\n        return feat\n    return wrap\n```\n\nThe above code can be interpreted as a nested loop.\n```python\n# Pseudo code\nfor each_x in x_pt:\n    for each_y in y_pt:\n        create_Point(each_x, each_y)\n```\nx_pt and y_pt are generated from the geopackage (AOI) using GeoPandas library as follows\n\n```python\ndef generatePoints(file_name, pixel_size):\n\n    # read the farm and convert to geojson\n    feature = gpd.read_file(file_name).__geo_interface__\n    # extract bounds\n    minx, miny, maxx, maxy = feature['bbox']\n    # create a list with spacing equal to pixel_size\n    x_pt = ee.List.sequence(minx, maxx, pixel_size)\n    y_pt = ee.List.sequence(miny, maxy, pixel_size)\n   \n    return x_pt, y_pt, minx, maxy\n```\nHere we are basically creating a new `Point` feature for each x and y point.\n\nOnce we have the grid over our AOI, we can go ahead and call `getRegion` method\n\nThe documentation does a good job in explaining what `getRegion` is all about\n\n>Output an array of values for each [pixel, band, image] tuple in an ImageCollection. The output contains rows of id, lon, lat, time, and all bands for each image that intersects each pixel in the given region. Attempting to extract more than 1048576 values will result in an error.\n\nThe limit 1048576 results in a max tile width and height of 1024 x 1024 pixels. By combining the previously created grid and `getRegion`, we could potentially get 100 times more pixels than getDownloadURL. Let us do that!\n\n```python\nlen_y = len(y_pt.getInfo())\nlen_x = len(x_pt.getInfo())\n\nimgCollection = ee.ImageCollection(\"COPERNICUS/S2_SR\").filters(filters_to_add)\ngeometry = ee.FeatureCollection(x_pt.map(xcor(y_pt, CRS))).flatten()\ninput_bands = \"B4\"\npixel_size = 10\n\ndf = get_dataframe(imgCollection, geometry, input_bands, CRS )\ndata_matrix = df[input_bands].values.reshape(len_y, len_x)\ndata_matrix = np.flip(data_matrix, axis = 0)\ntransform = rasterio.transform.from_origin(minx, maxy, pixel_size, pixel_size)\nsave_tiff(\"output.tif\", data_matrix, transform, CRS)\n```\nThe above code first gets the count of points in each of the 2-dimensions followed by fetching the dataframe which contains the lat, lon and pixel value as shown in the image.\n\n<figure>\n\n![](https://i.imgur.com/5SjjW0E.png)\n\n<figcaption align = \"center\"><b><i>Fig.2 -Output of getRegion results in lat, lon, pixel value in sequential order</i></b></figcaption>\n\n</figure>\n\n\nNow we reshape the dataframe and flip it to make the pixel arrange in image format. Lastly, we save the image by passing the transformation of the image. Make sure to have an imageCollection for the `getRegion` method to work. Currently, the above code can only download 1 band at a time, but with simple modification to the `getDataframe` function, that too can be changed.\n\n\n```python\ndef getDataframe(img_col, feature, input_band, crs):\n   \n    imgcol = ee.ImageCollection(img_col).select(input_band)\n    df = pd.DataFrame(imgcol.getRegion(feature.geometry(), 10, crs).getInfo())\n    df, df.columns = df[1:], df.iloc[0]\n    df = df.drop([\"id\", \"time\"], axis=1)\n\n    return df\n\ndef saveTiff(output_name, data_array, transform, crs):\n\n    options = {\n        \"driver\": \"Gtiff\",\n        \"height\": data_array.shape[0],\n        \"width\": data_array.shape[1],\n        \"count\": 1,\n        \"dtype\": np.float32,\n        \"crs\": crs,\n        \"transform\": transform\n    }\n\n    with rs.open(output_name, 'w', **options) as src:\n        src.write(data_array, 1)\n\n    return None\n```\n\nThe output of the exercise is that you have a raster directly downloaded to your local machine, without google drive/ cloud intermediaries. One thing worth pointing out, is for extremely large images, you are better off downloading via the specified steps in docs. This hacky way is to simplify things and avoid google drive (which is never empty for me).\n\n![](https://i.imgur.com/Z8DEJHh.jpg)\n\nThe full code can be accessed [here](https://github.com/amanbagrecha/ee-image-direct-download)\n\n\n\n","srcMarkdownNoYaml":"\n\nOftentimes you are required to download satellite images for your Area of Interest (AOI) and Google Earth Engine is probably a good place to avail processed satellite images for free and more importantly, only for the area you need.\n\nOne hindrance when you download from earth engine is that the images get saved in google drive, which can fill up fast for large numbers of downloads. To avoid this additional step, there is a hacky trick to download images directly.\n\nNote: Earth Engine does provide getDownloadURL option, but is limited in the size of download and thus not feasible in this case. Pixel grid dimensions for [getDownloadURL](https://developers.google.com/earth-engine/apidocs/ee-image-getdownloadurl) must be less than or equal to 10000 i.e, you can have a maximum of 100 x 100 pixel size images.\n\nIn this post I show a trick which can let you download upto 100 times larger size images, directly to your local machine. Spoiler: [getRegion](https://developers.google.com/earth-engine/apidocs/ee-imagecollection-getregion) method plays a significant role to help accomplish this task. Added to that, creating a gridded bounding box for our AOI, with spacing equivalent to the pixel size will aid in our task.\n\nWe will utilize earth engine python client so that all the geopython goodies can be simultaneously utilised.\n\nTo begin with, I have a geopackage containing a polygon, which is our AOI. We aim to download sentinel-2 B4 band for the region. The ideal way would be to use the in-built `Export` option, but in our case we would use the [getRegion](https://developers.google.com/earth-engine/apidocs/ee-imagecollection-getregion) method along with creating a point grid over our AOI with spacing equivalent to the pixel size.\n\n\n<figure>\n\n![](https://i.imgur.com/IA5OTuN.png)\n\n<figcaption align = \"center\"><b><i>Fig.1 -Left: Our Area of Interest over which to download satellite data. Right: Grid points over AOI bounding box at pixel spacing</i></b></figcaption>\n\n</figure>\n\nTo accomplish creation of points at spacing equal to pixel width and height, we use the following function\n\n```python\n# generate points\ndef xcor(y_pt, crs):\n    def wrap(x_each):\n        feat = ee.FeatureCollection(y_pt.map(lambda y_each: ee.Feature(\n            ee.Geometry.Point([x_each, y_each], ee.Projection(crs)))))\n        return feat\n    return wrap\n```\n\nThe above code can be interpreted as a nested loop.\n```python\n# Pseudo code\nfor each_x in x_pt:\n    for each_y in y_pt:\n        create_Point(each_x, each_y)\n```\nx_pt and y_pt are generated from the geopackage (AOI) using GeoPandas library as follows\n\n```python\ndef generatePoints(file_name, pixel_size):\n\n    # read the farm and convert to geojson\n    feature = gpd.read_file(file_name).__geo_interface__\n    # extract bounds\n    minx, miny, maxx, maxy = feature['bbox']\n    # create a list with spacing equal to pixel_size\n    x_pt = ee.List.sequence(minx, maxx, pixel_size)\n    y_pt = ee.List.sequence(miny, maxy, pixel_size)\n   \n    return x_pt, y_pt, minx, maxy\n```\nHere we are basically creating a new `Point` feature for each x and y point.\n\nOnce we have the grid over our AOI, we can go ahead and call `getRegion` method\n\nThe documentation does a good job in explaining what `getRegion` is all about\n\n>Output an array of values for each [pixel, band, image] tuple in an ImageCollection. The output contains rows of id, lon, lat, time, and all bands for each image that intersects each pixel in the given region. Attempting to extract more than 1048576 values will result in an error.\n\nThe limit 1048576 results in a max tile width and height of 1024 x 1024 pixels. By combining the previously created grid and `getRegion`, we could potentially get 100 times more pixels than getDownloadURL. Let us do that!\n\n```python\nlen_y = len(y_pt.getInfo())\nlen_x = len(x_pt.getInfo())\n\nimgCollection = ee.ImageCollection(\"COPERNICUS/S2_SR\").filters(filters_to_add)\ngeometry = ee.FeatureCollection(x_pt.map(xcor(y_pt, CRS))).flatten()\ninput_bands = \"B4\"\npixel_size = 10\n\ndf = get_dataframe(imgCollection, geometry, input_bands, CRS )\ndata_matrix = df[input_bands].values.reshape(len_y, len_x)\ndata_matrix = np.flip(data_matrix, axis = 0)\ntransform = rasterio.transform.from_origin(minx, maxy, pixel_size, pixel_size)\nsave_tiff(\"output.tif\", data_matrix, transform, CRS)\n```\nThe above code first gets the count of points in each of the 2-dimensions followed by fetching the dataframe which contains the lat, lon and pixel value as shown in the image.\n\n<figure>\n\n![](https://i.imgur.com/5SjjW0E.png)\n\n<figcaption align = \"center\"><b><i>Fig.2 -Output of getRegion results in lat, lon, pixel value in sequential order</i></b></figcaption>\n\n</figure>\n\n\nNow we reshape the dataframe and flip it to make the pixel arrange in image format. Lastly, we save the image by passing the transformation of the image. Make sure to have an imageCollection for the `getRegion` method to work. Currently, the above code can only download 1 band at a time, but with simple modification to the `getDataframe` function, that too can be changed.\n\n\n```python\ndef getDataframe(img_col, feature, input_band, crs):\n   \n    imgcol = ee.ImageCollection(img_col).select(input_band)\n    df = pd.DataFrame(imgcol.getRegion(feature.geometry(), 10, crs).getInfo())\n    df, df.columns = df[1:], df.iloc[0]\n    df = df.drop([\"id\", \"time\"], axis=1)\n\n    return df\n\ndef saveTiff(output_name, data_array, transform, crs):\n\n    options = {\n        \"driver\": \"Gtiff\",\n        \"height\": data_array.shape[0],\n        \"width\": data_array.shape[1],\n        \"count\": 1,\n        \"dtype\": np.float32,\n        \"crs\": crs,\n        \"transform\": transform\n    }\n\n    with rs.open(output_name, 'w', **options) as src:\n        src.write(data_array, 1)\n\n    return None\n```\n\nThe output of the exercise is that you have a raster directly downloaded to your local machine, without google drive/ cloud intermediaries. One thing worth pointing out, is for extremely large images, you are better off downloading via the specified steps in docs. This hacky way is to simplify things and avoid google drive (which is never empty for me).\n\n![](https://i.imgur.com/Z8DEJHh.jpg)\n\nThe full code can be accessed [here](https://github.com/amanbagrecha/ee-image-direct-download)\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en-GB","fig-responsive":true,"quarto-version":"1.3.450","theme":["sandstone","../../_variables.scss"],"page-layout":"article","fontsize":"1.1em","linestretch":1.7,"fontcolor":"black","author":[{"id":"cvc","number":1,"name":{"given":"Aman","family":"Bagrecha","literal":"Aman Bagrecha","non-dropping-particle":"von"},"orcid":"0000-0003-3131-0864","email":"jainaman588@gmail.com"}],"mermaid":{"theme":"neutral"},"title":"How to save Earth Engine Image directly to your local machine","date":"2022-02-07","slug":"how-to-save-earth-engine-image-directly-to-your-local-machine","categories":["earth-engine"],"tags":["earth-engine","python"],"subtitle":"","description":"In this post I show a trick which can let you download upto 100 times larger size images, directly to your local machine. Spoiler: `getRegion` method plays a significant role to help accomplish this task.","lastmod":"2022-02-07T22:19:19+05:30","featured":"no","image":"featured.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}