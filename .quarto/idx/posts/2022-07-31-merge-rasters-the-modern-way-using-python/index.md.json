{"title":"Merging Rasters using Rasterio","markdown":{"yaml":{"title":"Merging Rasters using Rasterio","date":"2022-08-07","slug":"merge-rasters-the-modern-way-using-python","categories":["Python"],"tags":[],"subtitle":"","description":"Use pystac-client to fetch and merge data. Also, understand the merge functionality of rasterio.","authors":[],"lastmod":"2022-08-07T10:55:30+05:30","featured":"no","image":"featured.jpg"},"headingText":"TL;DR","containsRefs":false,"markdown":"\n\nIn this blog, we'll examine how to merge or mosaic rasters using Python, the modern way. Additionally, we would look at a few nuances and internal workings of rasterio's merge functionality along with saving your rasters in-memory.\n\nBy \"modern way\", it is implied that you have an improved workflow and data management. And that you can experiment with various scenarios quickly and efficiently.\n\nThe traditional way to mosaic data is by downloading multiple intersecting tileset in its entirety. Downloading an entire tileset is itself a cost prohibitive task, added to already lost time in searching desired satellite imagery on GUI.\n\n\nTo overcome these traditional challenges, there has been significant improvement in storing metadata of satellite imagery (namely [STAC](https://stacspec.org/en)) which has enabled querying them much smoother and made it imagery-provider agnostic.\n\n\nWe would perform the following task in this blog 窶能n- Use pystac to query items over our AOI\n- Plot the tiles on map using hvplot\n- Merge tiles without data download on local machine\n- Save the merged tile in-memory using rasterio's MemoryFile\n- Internals of rasterio's merge methods\n\n\n---\n\n### Problem at hand\n\nI wish to access sentinel-2 True Color Image for the month of January over my area of interest (AOI), which is a highway network across Karnataka and Andhra Pradesh (Figure 1).\n\n\n\n<figure>\n\n![bokeh_plot](https://user-images.githubusercontent.com/76432265/183255775-352d47fb-515c-4d72-ba4e-e32ac5bebf42.png)\n\n<figcaption align = \"center\"><b><i>Fig.1 -\nHighway Network as our Region of Interest</ href> </i></b></figcaption>\n\n</figure>\n\n\nWe start by fetching sentinel-2 tiles over our AOI from `sentinel-s2-l2a-cogs` STAC catalog using [pystac-client](https://github.com/stac-utils/pystac-client). This library allows us to crawl STAC catalog and enables rapid access to the metadata we need.\n\n```python\n# STAC API root URL\n# Thanks to element84 for hosting the API for sentinel-2 catalog.\nURL = 'https://earth-search.aws.element84.com/v0/'\n\nclient = Client.open(URL)\n\nsearch = client.search(\n    max_items = 10,\n    collections = \"sentinel-s2-l2a-cogs\",\n    bbox = gdf.total_bounds, # geodataframe for our region of study\n    datetime = '2022-01-01/2022-01-24'\n)\n```\nIn the above code, we search for 10 sentinel-s2-l2a-cogs over our AOI for the date between January 1 and 24 of 2022.\n\nNow we need to know which of our 10 queried images covers our area of interest in its entirety. To do that, we can plot all the search results on the map and visually inspect.\n\n\n<figure>\n\n![bokeh_plot](https://user-images.githubusercontent.com/76432265/183255939-121e585e-79dc-4ceb-b61e-7e08709de926.png)\n\n<figcaption align = \"center\"><b><i>Fig.2 -\nSentinel-2 tiles overlaid on Region of Interest</ href> </i></b></figcaption>\n\n</figure>\n\n\n\nWe see that our AOI is not covered by a single tile in entirety, and that there is a need to merge adjacent tiles.\n\n\n> Note that we have so far only queried the metadata of our desired imagery\n\nWe use rasterio's [merge](https://rasterio.readthedocs.io/en/latest/api/rasterio.merge.html) functionality, which would enable us to combine all of them seamlessly.\n\nFirst, we get all the tiles for a single day and look for True Color Image (TCI) band\n\n```sh\n# retrieve the items as dictionaries, rather than Item objects\nitems = list(search.items_as_dicts())\n# convert found items to a GeoDataFrame\nitems_gdf = items_to_geodataframe(items)\n\ntiles_single_day = items_gdf.loc['2022-01-23', \"assets.visual.href\"]\n\n# print(tiles_single_day)\n properties.datetime\n 2022-01-23 05:25:14+00:00    https://sentinel-cogs.s3.us-west-2.amazonaws.c...\n 2022-01-23 05:25:11+00:00    https://sentinel-cogs.s3.us-west-2.amazonaws.c...\n 2022-01-23 05:24:59+00:00    https://sentinel-cogs.s3.us-west-2.amazonaws.c...\n 2022-01-23 05:24:56+00:00    https://sentinel-cogs.s3.us-west-2.amazonaws.c...\n Name: assets.visual.href, dtype: object\n\n```\n\n\nNext, read the remote files via the URL in the above output using `rasterio.open` and save the returned file handlers as a list. This is the first instance where we are dealing with the actual imagery. Although, we are not reading the values stored in the data just yet.\n\n```py\n# open images stored on s3\nfile_handler = [rasterio.open(row) for row in tiles_single_day]\n```\n\nFinally we can merge all of the tiles and get the clipped raster stored in memory. \n\n```py\nfrom rasterio.io import MemoryFile\nfrom rasterio.merge import merge\n\nmemfile = MemoryFile()\n\nmerge(datasets=file_handler, # list of dataset objects opened in 'r' mode\n    bounds=tuple(gdf.set_crs(\"EPSG:4326\").to_crs(file_handler[0].crs).total_bounds), # tuple\n    nodata=None, # float\n    dtype='uint16', # dtype\n    resampling=Resampling.nearest,\n    method='first', # strategy to combine overlapping rasters\n    dst_path=memfile.name, # str or PathLike to save raster\n    dst_kwds={'blockysize':512, 'blockxsize':512} # Dictionary\n  )\n```\n\nThere are really interesting things to look at in the above code. Overall, the code above returns a `MemoryFile` object which contains a `uint16` raster with bounds of our AOI and blocksize of 512. The attribute `dst_path` allows us to specify a path to save the output as a raster. What is interesting is we can not only pass a file path to save on local disk but also a virtual path and save the merged raster **in-memory**, avoiding clutter of additional files on disk.\n\nTo define a virtual path, we use rasterio's `MemoryFile` class. When we create a `MemoryFile` object, it has a `name` attribute which gives us a virtual path, thus treating it as a real file (using GDALs [vsimem](https://gdal.org/user/virtual_file_systems.html#vsimem-in-memory-files) internally). This MemoryFile object (`memfile` here) provides us all the methods and attributes of rasterio's file handler, which is extremely helpful.\n\n\n```py\nprint(memfile.open().profile)\n\n{'driver': 'GTiff', 'dtype': 'uint16', 'nodata': 0.0, 'width': 4110, 'height': 3211, 'count': 3, 'crs': CRS.from_epsg(32643), 'transform': Affine(10.0, 0.0, 788693.4700669964,\n       0.0, -10.0, 1500674.3670768766), 'blockxsize': 512, 'blockysize': 512, 'tiled': True, 'compress': 'deflate', 'interleave': 'pixel'}\n\n```\n\nThe `method='first'` tells us the strategy used to determine the value of the pixel where the rasters overlap. In this case, the pixel value from the first imagery of the overlapping region in the list, is used as the value for the output raster.\n\nThe entire algorithm to merge rasters is illustrated in the figure below by taking an example of combining two rasters with `method=first`.\n\n<figure>\n\n![merge-rasterio-with-laberl_merging-rasters](https://user-images.githubusercontent.com/76432265/183279200-05b96cd5-f0a7-48e0-9b37-480792756d16.jpg)\n\n<figcaption align = \"center\"><b><i>Fig.3 -\nInternal working of rasterio's merge functionality. src1 and src2 are two overlapping raster.</ href> </i></b></figcaption>\n\n\n</figure>\n\nFrom the above figure, for each raster in the list:\n- it finds the intersection with the **Output Bounds** (named `region` in the figure)\n\n- next, it gets a boolean mask of invaild pixel over the `region` (named `region_mask` in the figure). \n\n\n- next, it copies over all the existing values from the raster for the `region` to an array (named `temp` in the figure)\n\n- It gets a boolean mask for the valid pixels in the `temp` array. (named `temp_mask` in the figure)\n\n- With these four arrays, it runs the `method=first`, which is to\n  - create the same shaped array as that of `region` and fill values with negation of `region_mask` (named `A` in the figure)\n  - create a filter by combining `region_mask` and `A` with a AND gate (named `B` in the figure)\n  - copy over the values from `temp` to `region` using `B` as the filter\n\nThese series of steps are performed for all the rasters in the list. Finally, the output at the end of each iteration is combined to produce `dest` raster. \n\n> Notice the dark strip bands for each array which represents the overlapping region. Also notice that values from the dark strip in step **`1`** did not change at the end of step **`2`** \n\n---\n\n\n### Custom combining strategy for overlapping regions\n\n\nWe can have arbitrary conditions on how to combine the overlapping region. By default rasterio uses values of the first overlapping raster from the list of Input files as pixel values for the output raster file. It has several other options in its utility such as `min`, `max`, `sum`, `count`, `last`.\n\nTo define our custom method, say in this case, I want to take the average of all the pixel values over my overlapping region and copy them to the output file. To do that, we can override the method by defining our custom method. Let us see how 窶能n\nWe take a look at the source code of built-in methods which make use of two or more rasters to make decisions on the output pixel values. Few such methods which do that are `copy_sum`, `copy_min`, `copy_max`, `copy_count`.\n\n\nLooking at the [copy_min](https://github.com/rasterio/rasterio/blob/main/rasterio/merge.py#L40) from source code, we see that it performs two logical operations each before and after the custom logic we wish to apply.\n\n\n<figure>\n\n![image](https://user-images.githubusercontent.com/76432265/183279064-f2437364-b4bd-4761-8b99-2aa3bc65bc42.png)\n\n<figcaption align = \"center\"><b><i>Fig.4 -\ncopy_min function copies minimum value from overlapping region to the output raster</ href> </i></b></figcaption>\n\n</figure>\n\n\n\nWe would replace our custom logic of averaging with that of `minimum` in the above code and that is all there is to it. We can now use this function to manipulate the values of overlapping region!\n\n```py\ndef custom_method_avg(merged_data, new_data, merged_mask, new_mask, **kwargs):\n    \"\"\"Returns the average value pixel.\"\"\"\n    mask = np.empty_like(merged_mask, dtype=\"bool\")\n    np.logical_or(merged_mask, new_mask, out=mask)\n    np.logical_not(mask, out=mask)\n    np.nanmean([merged_data, new_data], axis=0, out=merged_data, where=mask)\n    np.logical_not(new_mask, out=mask)\n    np.logical_and(merged_mask, mask, out=mask)\n    np.copyto(merged_data, new_data, where=mask, casting=\"unsafe\")\n```\n\n\n\n\n---\n\n### Endnote\n\nThe modern approach to merge rasters in python is to only stream the data for your region of interest, process and perform analysis on the raster in memory. This would save you a huge cost and time. This is possible because of [COGs](https://www.cogeo.org/) and [STAC](https://stacspec.org/en).\n\nWe looked at the merge method in depth and also explored the techniques used to combine the overlapping data. Finally, we created a custom method for merging rasters by modifying the existing code to suit our requirements. The code associated with this post can be found [here](https://colab.research.google.com/drive/1iMYdNmAEr0JuKzPnDH0qC4rDsYkvwMk0?usp=sharing).\n","srcMarkdownNoYaml":"\n\nIn this blog, we'll examine how to merge or mosaic rasters using Python, the modern way. Additionally, we would look at a few nuances and internal workings of rasterio's merge functionality along with saving your rasters in-memory.\n\nBy \"modern way\", it is implied that you have an improved workflow and data management. And that you can experiment with various scenarios quickly and efficiently.\n\nThe traditional way to mosaic data is by downloading multiple intersecting tileset in its entirety. Downloading an entire tileset is itself a cost prohibitive task, added to already lost time in searching desired satellite imagery on GUI.\n\n\nTo overcome these traditional challenges, there has been significant improvement in storing metadata of satellite imagery (namely [STAC](https://stacspec.org/en)) which has enabled querying them much smoother and made it imagery-provider agnostic.\n\n### TL;DR\n\nWe would perform the following task in this blog 窶能n- Use pystac to query items over our AOI\n- Plot the tiles on map using hvplot\n- Merge tiles without data download on local machine\n- Save the merged tile in-memory using rasterio's MemoryFile\n- Internals of rasterio's merge methods\n\n\n---\n\n### Problem at hand\n\nI wish to access sentinel-2 True Color Image for the month of January over my area of interest (AOI), which is a highway network across Karnataka and Andhra Pradesh (Figure 1).\n\n\n\n<figure>\n\n![bokeh_plot](https://user-images.githubusercontent.com/76432265/183255775-352d47fb-515c-4d72-ba4e-e32ac5bebf42.png)\n\n<figcaption align = \"center\"><b><i>Fig.1 -\nHighway Network as our Region of Interest</ href> </i></b></figcaption>\n\n</figure>\n\n\nWe start by fetching sentinel-2 tiles over our AOI from `sentinel-s2-l2a-cogs` STAC catalog using [pystac-client](https://github.com/stac-utils/pystac-client). This library allows us to crawl STAC catalog and enables rapid access to the metadata we need.\n\n```python\n# STAC API root URL\n# Thanks to element84 for hosting the API for sentinel-2 catalog.\nURL = 'https://earth-search.aws.element84.com/v0/'\n\nclient = Client.open(URL)\n\nsearch = client.search(\n    max_items = 10,\n    collections = \"sentinel-s2-l2a-cogs\",\n    bbox = gdf.total_bounds, # geodataframe for our region of study\n    datetime = '2022-01-01/2022-01-24'\n)\n```\nIn the above code, we search for 10 sentinel-s2-l2a-cogs over our AOI for the date between January 1 and 24 of 2022.\n\nNow we need to know which of our 10 queried images covers our area of interest in its entirety. To do that, we can plot all the search results on the map and visually inspect.\n\n\n<figure>\n\n![bokeh_plot](https://user-images.githubusercontent.com/76432265/183255939-121e585e-79dc-4ceb-b61e-7e08709de926.png)\n\n<figcaption align = \"center\"><b><i>Fig.2 -\nSentinel-2 tiles overlaid on Region of Interest</ href> </i></b></figcaption>\n\n</figure>\n\n\n\nWe see that our AOI is not covered by a single tile in entirety, and that there is a need to merge adjacent tiles.\n\n\n> Note that we have so far only queried the metadata of our desired imagery\n\nWe use rasterio's [merge](https://rasterio.readthedocs.io/en/latest/api/rasterio.merge.html) functionality, which would enable us to combine all of them seamlessly.\n\nFirst, we get all the tiles for a single day and look for True Color Image (TCI) band\n\n```sh\n# retrieve the items as dictionaries, rather than Item objects\nitems = list(search.items_as_dicts())\n# convert found items to a GeoDataFrame\nitems_gdf = items_to_geodataframe(items)\n\ntiles_single_day = items_gdf.loc['2022-01-23', \"assets.visual.href\"]\n\n# print(tiles_single_day)\n properties.datetime\n 2022-01-23 05:25:14+00:00    https://sentinel-cogs.s3.us-west-2.amazonaws.c...\n 2022-01-23 05:25:11+00:00    https://sentinel-cogs.s3.us-west-2.amazonaws.c...\n 2022-01-23 05:24:59+00:00    https://sentinel-cogs.s3.us-west-2.amazonaws.c...\n 2022-01-23 05:24:56+00:00    https://sentinel-cogs.s3.us-west-2.amazonaws.c...\n Name: assets.visual.href, dtype: object\n\n```\n\n\nNext, read the remote files via the URL in the above output using `rasterio.open` and save the returned file handlers as a list. This is the first instance where we are dealing with the actual imagery. Although, we are not reading the values stored in the data just yet.\n\n```py\n# open images stored on s3\nfile_handler = [rasterio.open(row) for row in tiles_single_day]\n```\n\nFinally we can merge all of the tiles and get the clipped raster stored in memory. \n\n```py\nfrom rasterio.io import MemoryFile\nfrom rasterio.merge import merge\n\nmemfile = MemoryFile()\n\nmerge(datasets=file_handler, # list of dataset objects opened in 'r' mode\n    bounds=tuple(gdf.set_crs(\"EPSG:4326\").to_crs(file_handler[0].crs).total_bounds), # tuple\n    nodata=None, # float\n    dtype='uint16', # dtype\n    resampling=Resampling.nearest,\n    method='first', # strategy to combine overlapping rasters\n    dst_path=memfile.name, # str or PathLike to save raster\n    dst_kwds={'blockysize':512, 'blockxsize':512} # Dictionary\n  )\n```\n\nThere are really interesting things to look at in the above code. Overall, the code above returns a `MemoryFile` object which contains a `uint16` raster with bounds of our AOI and blocksize of 512. The attribute `dst_path` allows us to specify a path to save the output as a raster. What is interesting is we can not only pass a file path to save on local disk but also a virtual path and save the merged raster **in-memory**, avoiding clutter of additional files on disk.\n\nTo define a virtual path, we use rasterio's `MemoryFile` class. When we create a `MemoryFile` object, it has a `name` attribute which gives us a virtual path, thus treating it as a real file (using GDALs [vsimem](https://gdal.org/user/virtual_file_systems.html#vsimem-in-memory-files) internally). This MemoryFile object (`memfile` here) provides us all the methods and attributes of rasterio's file handler, which is extremely helpful.\n\n\n```py\nprint(memfile.open().profile)\n\n{'driver': 'GTiff', 'dtype': 'uint16', 'nodata': 0.0, 'width': 4110, 'height': 3211, 'count': 3, 'crs': CRS.from_epsg(32643), 'transform': Affine(10.0, 0.0, 788693.4700669964,\n       0.0, -10.0, 1500674.3670768766), 'blockxsize': 512, 'blockysize': 512, 'tiled': True, 'compress': 'deflate', 'interleave': 'pixel'}\n\n```\n\nThe `method='first'` tells us the strategy used to determine the value of the pixel where the rasters overlap. In this case, the pixel value from the first imagery of the overlapping region in the list, is used as the value for the output raster.\n\nThe entire algorithm to merge rasters is illustrated in the figure below by taking an example of combining two rasters with `method=first`.\n\n<figure>\n\n![merge-rasterio-with-laberl_merging-rasters](https://user-images.githubusercontent.com/76432265/183279200-05b96cd5-f0a7-48e0-9b37-480792756d16.jpg)\n\n<figcaption align = \"center\"><b><i>Fig.3 -\nInternal working of rasterio's merge functionality. src1 and src2 are two overlapping raster.</ href> </i></b></figcaption>\n\n\n</figure>\n\nFrom the above figure, for each raster in the list:\n- it finds the intersection with the **Output Bounds** (named `region` in the figure)\n\n- next, it gets a boolean mask of invaild pixel over the `region` (named `region_mask` in the figure). \n\n\n- next, it copies over all the existing values from the raster for the `region` to an array (named `temp` in the figure)\n\n- It gets a boolean mask for the valid pixels in the `temp` array. (named `temp_mask` in the figure)\n\n- With these four arrays, it runs the `method=first`, which is to\n  - create the same shaped array as that of `region` and fill values with negation of `region_mask` (named `A` in the figure)\n  - create a filter by combining `region_mask` and `A` with a AND gate (named `B` in the figure)\n  - copy over the values from `temp` to `region` using `B` as the filter\n\nThese series of steps are performed for all the rasters in the list. Finally, the output at the end of each iteration is combined to produce `dest` raster. \n\n> Notice the dark strip bands for each array which represents the overlapping region. Also notice that values from the dark strip in step **`1`** did not change at the end of step **`2`** \n\n---\n\n\n### Custom combining strategy for overlapping regions\n\n\nWe can have arbitrary conditions on how to combine the overlapping region. By default rasterio uses values of the first overlapping raster from the list of Input files as pixel values for the output raster file. It has several other options in its utility such as `min`, `max`, `sum`, `count`, `last`.\n\nTo define our custom method, say in this case, I want to take the average of all the pixel values over my overlapping region and copy them to the output file. To do that, we can override the method by defining our custom method. Let us see how 窶能n\nWe take a look at the source code of built-in methods which make use of two or more rasters to make decisions on the output pixel values. Few such methods which do that are `copy_sum`, `copy_min`, `copy_max`, `copy_count`.\n\n\nLooking at the [copy_min](https://github.com/rasterio/rasterio/blob/main/rasterio/merge.py#L40) from source code, we see that it performs two logical operations each before and after the custom logic we wish to apply.\n\n\n<figure>\n\n![image](https://user-images.githubusercontent.com/76432265/183279064-f2437364-b4bd-4761-8b99-2aa3bc65bc42.png)\n\n<figcaption align = \"center\"><b><i>Fig.4 -\ncopy_min function copies minimum value from overlapping region to the output raster</ href> </i></b></figcaption>\n\n</figure>\n\n\n\nWe would replace our custom logic of averaging with that of `minimum` in the above code and that is all there is to it. We can now use this function to manipulate the values of overlapping region!\n\n```py\ndef custom_method_avg(merged_data, new_data, merged_mask, new_mask, **kwargs):\n    \"\"\"Returns the average value pixel.\"\"\"\n    mask = np.empty_like(merged_mask, dtype=\"bool\")\n    np.logical_or(merged_mask, new_mask, out=mask)\n    np.logical_not(mask, out=mask)\n    np.nanmean([merged_data, new_data], axis=0, out=merged_data, where=mask)\n    np.logical_not(new_mask, out=mask)\n    np.logical_and(merged_mask, mask, out=mask)\n    np.copyto(merged_data, new_data, where=mask, casting=\"unsafe\")\n```\n\n\n\n\n---\n\n### Endnote\n\nThe modern approach to merge rasters in python is to only stream the data for your region of interest, process and perform analysis on the raster in memory. This would save you a huge cost and time. This is possible because of [COGs](https://www.cogeo.org/) and [STAC](https://stacspec.org/en).\n\nWe looked at the merge method in depth and also explored the techniques used to combine the overlapping data. Finally, we created a custom method for merging rasters by modifying the existing code to suit our requirements. The code associated with this post can be found [here](https://colab.research.google.com/drive/1iMYdNmAEr0JuKzPnDH0qC4rDsYkvwMk0?usp=sharing).\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../_variables.scss"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en-GB","fig-responsive":true,"quarto-version":"1.3.450","theme":["sandstone"],"page-layout":"article","fontsize":"1.1em","linestretch":1.7,"fontcolor":"black","author":[{"id":"cvc","number":1,"name":{"given":"Aman","family":"Bagrecha","literal":"Aman Bagrecha","non-dropping-particle":"von"},"orcid":"0000-0003-3131-0864","email":"jainaman588@gmail.com"}],"mermaid":{"theme":"neutral"},"title":"Merging Rasters using Rasterio","date":"2022-08-07","slug":"merge-rasters-the-modern-way-using-python","categories":["Python"],"tags":[],"subtitle":"","description":"Use pystac-client to fetch and merge data. Also, understand the merge functionality of rasterio.","authors":[],"lastmod":"2022-08-07T10:55:30+05:30","featured":"no","image":"featured.jpg"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}